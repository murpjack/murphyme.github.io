{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/how-to-handle-async-behaviour","result":{"data":{"markdownRemark":{"html":"<h2>TL;DR</h2>\n<p>Asynchronous code in JavaScript can become messy. Asynchronous operations such as http requests, can be made to behave by using a few different methods. These include the Async/Await API, vanilla callbacks, the promise API, or by using the Fluture library.\nBelow is an outline of methods for handling async code. The Fluture library is objectively a great choice since it is elegant, efficient and reliable. A caveat is that there is often a right tool, or tools for each and every job. To use a small brush to paint the living room wall for instance would be daft.   </p>\n<h2>STL;DR - Still Too Long; Didn't Read</h2>\n<p>Fluture is a great library. Small paintbrushes = bad.</p>\n<h2>Fundamental</h2>\n<p>I am passionate about writing readable, reliable code. Functional paradigms(pure functions) and the idea of <em>keeping it simple</em> (K.I.S.S) should <strong>always</strong> be utilised, to ensure that code is readable, reusable and reliable. In JavaScript it is possible to do this.</p>\n<blockquote>\n<p>As programs get bigger, they also become more complex and harder to understand.<sup>1</sup></p>\n</blockquote>\n<p>JavaScript is a single thread language, which means that it is inherently synchronous. This means it processes one statement at a time. If you call two functions they will be run in the order they are called. Some operations in JavaScript can take a little while to complete. An example is the setTimeout method, or an http request. The JavaScript interpreter then looks at subsequent lines in the same file without waiting for the result. Such operations are asynchronous and can become messy.</p>\n<h2>Asynchronous behaviour</h2>\n<p>There are a few methods of how to handle Asynchronous code. Each method has strengths, and may suit a particular situation. Some methods are eloquent and scalable, while some are more simple and don't scale well. Methods include:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">Async/Await API</a></li>\n<li>Callback functions</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\">Promise API (Promises)</a></li>\n<li><a href=\"https://github.com/fluture-js/Fluture\">Fluture library (Futures)</a></li>\n</ul>\n<p>An loose analogy for the difference between Promises and Futures, that is Fluture, would be:\nTo imagine pouring water first down a system of open pipes and then down a system of closed pipes. In the closed scenario any changes to the water or any other changes will only be seen once the water reaches the end of the last pipe. With Promises it is possible to execute a function in a ‘.then()’ callback, before the promise is consumed. This is not possible with Futures.\nThis analogy is not a perfect representation of either Futures or Promises. but explains one difference between the two in a way that I have found helpful.</p>\n<p><strong>Async/Await</strong>\nThe async and await keywords enable asynchronous, promise-based behaviour to be written in a cleaner style, avoiding the need to explicitly configure promise chains.<sup>2</sup></p>\n<p>Await expressions suspend progress through an async function, yielding control and subsequently resuming progress only when an awaited promise-based asynchronous operation is either fulfilled or rejected.<sup>3</sup></p>\n<ul>\n<li>Compatible with modern browsers</li>\n<li>less code, cleaner looking in more simple operations</li>\n<li>error handling is not required (though can be added with try/catch)</li>\n</ul>\n<p><strong>Vanilla callbacks</strong>\nA callback function is a function that is called inside another function.</p>\n<ul>\n<li>Works in IE11, and modern browsers</li>\n<li>Readable, in simple functions</li>\n<li>Not readable/ doesn’t scale well in larger chains of functions</li>\n</ul>\n<p><strong>Promise API</strong> (Promises)\nA Promise is an object representing the eventual completion or failure of an asynchronous operation.<sup>4</sup></p>\n<p>Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.<sup>5</sup></p>\n<ul>\n<li>Compatible with modern browsers</li>\n<li>Simple to use, gentle learning curve, widely used, which means many tutorials</li>\n<li>Hungry execution\noperations inside each callback can manipulate environment before the whole Promise chain is consumed</li>\n<li>error handling is not required, this is bad practice</li>\n</ul>\n<p><strong>Fluture</strong> (Futures)\nFluture is an abstraction which serves to reduce the complexity of dealing with JavaScripts asynchronous nature.<sup>6</sup></p>\n<p>Future instances are slightly different from Promise instances, in that they represent an asynchronous computation as opposed to an asynchronously acquired value.<sup>7</sup></p>\n<ul>\n<li>Universally compatible (includes IE11)</li>\n<li>Lazy in execution – only consumed triggers internal operations, when a Future is consumed.</li>\n<li>Nicer than promises to debug</li>\n<li>Stack safe composition and recursion</li>\n<li>Great documentation on Github</li>\n<li>Fairly steep learning curve - Introduction to functional paradigms</li>\n<li>Less tutorials</li>\n</ul>\n<p>When learning about Fluture, as per a colleague’s recommendation, it wasn’t easy to find tutorials. I relied on some articles by broccoli code and others.</p>\n<p>Much like Promises, Futures represent the value arising from the success or failure of an asynchronous operation (I/O). Though unlike Promises, Futures are lazy.</p>\n<h2>Summary</h2>\n<p>It is equal parts, reliability, and ninja skill points that make Futures a great complement to a js file and Should where possible be preferred to control any asynchronous code, though in a shared codebase, it may make those less familiar with functional programming paradigms or node callbacks scratch their heads at first.\nThe learning curve attached to the Fluture library can seem steep, but this investment will pay off and will absolutely make you a better developer.</p>\n<p>That it is important to choose the right tool for the job.\nTo use a tiny brush to paint the living room wall is a poor choice.\nTimes when each may be appropriate.</p>\n<p><sup>1</sup>Eloquent JavaScript, on Functional programming; <sup>2-3</sup><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">Async functions, MDN</a>;\n<sup>4-5</sup><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\">Using Promises</a>;\n<sup>6-7</sup> <a href=\"https://dev.to/avaq/fluture-a-functional-alternative-to-promises-21b\">How to use Flutures</a>;\n<a href=\"https://survivejs.com/blog/fluture-interview/\">Interview with Aldwin Vlasblom</a>.</p>","frontmatter":{"isArticle":true,"date":"July 17, 2020","slug":"/blog/how-to-handle-async-behaviour","title":"How to handle Asynchronous behaviour","tag":"#Webdev"},"excerpt":"TL;DR Asynchronous code in JavaScript can become messy. Asynchronous operations such as http requests, can be made to behave by using a few…"}},"pageContext":{"slug":"/blog/how-to-handle-async-behaviour"}}}